---
title: "Calculate D-score and DAZ"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
biblio-style: "apalike"
vignette: >
  %\VignetteIndexEntry{Calculate D-score and DAZ}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE, fig.retina = 2)
  options(width = 80)
```

## Overview

The D-score is a one-number summary measure of early child development. This vignettes shows how to estimate the D-score and the D-score SDS (also known as *D-score Age adjusted Z-score*, or DAZ) from individual pass/fail data. The vignettes covers some typical actions needed when estimating D-scores:

1. Rename item names in source data to item names used in itembank;
2. Reorganize the source data into a long matrix;
3. Calculate D-score and DAZ;
4. Combine D-score and DAZ with source data.

## 1. Rename item names

The `dscore` package has built-in subset of data from the POPS study [@verloove-vanhorick1986]. The dataset is called `popsdemo`.

```{r rename}
library("dscore")

head(popsdemo[, 1:10], 5)
nrow(popsdemo)
```

There are 25 children, with four time points each. The names of the items that form the entire test are obtained from columns 8-64.
```{r}
items <- names(popsdemo)[8:64]
```

The names of the items in the data need to be matched against one of the lexicons in the item bank. The item bank in the `dscore` package is called `itembank`. For each item, the item bank contains: 

1. The name of the item according to some lexicon (i.e. naming system);
2. The visit number (`occ`) according to the Dutch child health care system; 
2. The label of the item, both in English and Dutch;
3. The difficulty level of the item, as estimated by the Rasch model [@vanbuuren2014gc].

The built-in lexicons are:

```{r}
names(itembank)[grep("lex_", names(itembank))]
```

We first need to find out a proper lexicon for the data. The POPS data are already coded in the
`lex_ghap` lexicon. We may verify the item names in the data against the item names in the item bank.

```{r}
itemset <- !is.na(itembank$lex_dutch1983)
head(cbind(items, itembank[itemset, c("lex_ghap")]))
```

In this case all item names from the source data and the item bank match up exactly, but in general, we will need to map carefully the names in the dataset to the names in one of the lexicons provided by the item bank. 

For POPS, we may take out the relevant parts of the item bank as

```{r}
ib <- itembank[itemset,c("lex_dutch1983", "lex_ghap", "labelEN", "tau")]
head(ib, 3)
```

From here on, we will work in the GHAP lexicon. Renaming the source data is now done by

```{r}
item_locations <- names(popsdemo) %in% items
names(popsdemo)[item_locations] <- as.character(ib$lex_ghap)
```

The source data has now names that are recognized in the itembank. To check this, find the difficulties for each item by the `gettau()` function:

```{r}
gettau(items = names(popsdemo)[item_locations])
```

## 2. Reorganize the data into a long matrix

The `dscore_vector()` function takes vectors of item scores, item names and ages. Rearringing the data makes it easy to extract the relevant vectors. We need to create a data set with the following variables: `patid`, `moment`, `age`, `daycor`, `item` and `score`, and select only the rows where we have an observed score.

```{r warnings=FALSE, message=FALSE}
library("tidyr")
library("dplyr")
data <- popsdemo %>% 
  select(patid, moment, age, daycor, GSFIXEYE:GSKIK) %>%
  gather(items, scores, GSFIXEYE:GSKIK, na.rm = TRUE) %>%
  arrange(patid, moment)
head(data)
```

There are `r nrow(data)` records with a nonmissing item score.

## 3. Calculate D-score and DAZ

For illustration, let us first calculate the D-score of the first child, with ID 11126. There are 75 scores for this child, spread over four time points. This is a preterm child, so we correct calener age for gestational age as in `daycor`:

```{r}
child1 <- filter(data, patid == 11126)

scores <- child1$scores
items <- as.character(child1$items)
ages <- round(child1$daycor/365.25, 4)

# calculate dscore and daz for each time point for given child
(d <- dscore_vector(scores, items, ages))
daz(d)
```

If desired, one may also back-calculate the D-score from the standard deviation score by 
```{r}
zad(daz(d))
```

If we specify the child identifier \code{patid} as a by-group variable, 
we may calculate the D-score and DAZ for all children by

```{r}
# use age corrected for gestational age
data <- data.frame(data)
data$ages <- round(data$daycor/365.25, 4)

# calculate D-score and DAZ
ds <- split(data, data$patid)
dl <- parallel::mclapply(ds, FUN = dscore_vector)
dazl <- lapply(dl, FUN = daz)
df <- data.frame(
  patid = rep(as.numeric(names(dl)), times = unlist(lapply(dl, length))),
  ages = as.numeric(unlist(lapply(dl, names))),
  dscore = as.numeric(unlist(dl)),
  daz = as.numeric(unlist(dazl)))
head(df)
```

## 4. Combine D-score and DAZ with source data

Finally, in order to do further analyses, we need to put the estimated D-score and DAZ back into the source data.

```{r}
# merge dscore and daz into popsdemo data
popsdemo$ages <- round(popsdemo$daycor/365.25, 4)
popsdemo <- merge(popsdemo, df, all.x = TRUE)
head(select(popsdemo, patid, moment, ages, dscore, daz))
```

## References

