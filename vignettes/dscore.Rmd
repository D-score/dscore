---
title: "Calculate D-score and DAZ"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

This vignettes shows how to estimate the D-score and the D-score SDS, a.k.a. DAZ in an excerpt from the POPS data. This vignettes covers some typical actions needed when estimating D-scores:

1. Rename item names in source data to item names used in itembank
2. Reorganize the source data into a long matrix
3. Calculate D-score and DAZ
4. Combine D-score and DAZ with source data

## Rename item names

The `dscore` package has built-in example data from the POPS study. The data set is of class `tbl_df` from the `dplyr` package. 

```{r rename}
library("dscore")

pops
class(pops)
nrow(pops)
```

The are 25 children and 4 time points. 

```{r children}
# 25 children, 4 time points per child
length(unique(pops$patid))
```

The item scores are located in columns 11-67, and their names are:
```{r}
names(pops)[11:67]
```

These names need to be matched against one of the lexicons in the item bank. The built-in lexicons are:

```{r}
names(itembank)[1:5]
```

In the sequel, we will use the GHAP lexicon. The items for which we have difficulty estimates `tau` in this 
lexicon is

```{r}
ib <- itembank[!is.na(itembank$tau),c("lex.GHAP", "labelEN", "tau")]
head(ib, 3)
```

In this case, we tend to be lucky that the item names from the source data and the item bank match up exactly.

```{r}
head(data.frame(source = names(pops)[11:67], ghap = ib$lex.GHAP))
```

Renaming the source data is now easy:

```{r}
names(pops)[11:67] <- as.character(ib$lex.GHAP)
names(pops)
```

The source data has now names that are recognized in the itembank. To check this, find the difficulties for each item by the `gettau()` function:

```{r}
gettau(names(pops)[11:67])
```

## Reorganize the data into a long matrix

The `dscore()` function takes vectors of item scores, item names and ages. Rearringing the data makes it easy to extract the relevant vectors. We need to create a data set with the following variables: `patid`, `moment`, `age`, `daycor`, `item` and `score`, and select only the rows where we have an observed score.

```{r}
library("tidyr")
library("dplyr")
data <- pops %>% 
  select(patid, moment, age, daycor, GSFIXEYE:GSKIK) %>%
  gather(items, scores, GSFIXEYE:GSKIK, na.rm = TRUE) %>%
  mutate(scores = 1 - scores) %>% 
  arrange(patid, moment)
data
```

There are `nrow(data)` records with a nonmissing item score. Note also that the item scores have been reversed, as POPS uses a zero for a PASS, and a one for a FAIL.

## Calculate D-score and DAZ

For illustration, let us first calculate the D-score of the first child. There are 75 scores for this child, spread over four time points. This is a preterm child, so we correct calener age for gestational age as in `daycor`:

```{r}
child1 <- filter(data, patid == 1)

scores <- child1$scores
items <- as.character(child1$items)
ages <- round(child1$daycor/365.25, 4)

# calculate dscore and daz for each time point for given child
(d <- dscore(scores, items, ages))
(DAZ <- daz(d))
```

If desired, one may also back-calculate the D-score from the standard deviation score by 
```{r}
zad(DAZ)
```

If we specify the child identifier \code{patid} as a by-group variable, 
we may calculate the D-score and DAZ for all children by

```{r eval = FALSE}
## still a bit messy, but works for now, looking for dplyr solution
data <- data.frame(data)
data$ages <- round(data$daycor/365.25, 4)
ds <- split(data[, c("patid", "items", "scores", "ages")], f = data$patid)
dl <- lapply(ds, FUN = dscore)  # repeat estimation per person
dazl <- lapply(dl, FUN = daz)
d <- as.numeric(unlist(dl))
DAZ <- as.numeric(unlist(dazl))
```

## Combine D-score and DAZ with source data


```{r}
# still needs some work

# prepare for join
summ <- as.tbl(data) %>%
  group_by(patid, moment) %>%
  summarise(nd = n()) %>%
  ungroup()
summ <- data.frame(summ, d = d, DAZ = DAZ, 
          idc = as.character(summ$patid), moc = as.character(summ$moment))

```

```{r}
pops <- mutate(pops, idc = as.character(patid), moc = as.character(moment))
```

```{r join}
# and join
pops2 <- left_join(pops, summ, by = c("idc", "moc"))
print(select(pops2, idc, moc, nd, d, DAZ), n = 15)
```


